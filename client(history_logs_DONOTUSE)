#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h> 
#include <sys/uio.h>
#include "clue.h"
#include "ncur.h"

#define SITU_DICE_ROLL		(1000)		// 주사위를 굴림
#define SITU_DICE_SELECT	(1001)		// 굴린 주사위 내에서 값 선택
#define SITU_GOLDEN_CARD	(1002)		// 황금 카드를 발동
#define SITU_TURN_INFO		(1003)		// 플레이어의 턴을 나타냄
#define SITU_WIN			(1004)		// 플레이어 승리
#define SITU_LOSE			(1005)		// 플레이어 패배

/* 게임 진행 시 누적되는 추리 내역 히스토리를 저장하는 배열    */
char* history[1024] = { 0, };
int history_cnt=0;		// 히스토리의 개수를 누적하는 변수


int ui_update(WINDOW *window, Player_packet* player_packet);

/* ui_update() 함수에서 사용될 sub 함수 */

int show_history(WINDOW *window, Player_packet *player_pakcet);
int show_game_log(WINDOW *window, Player_packet *player_packet, int situation);
void print_history(WINDOW *window, int start_index);

// ----------------------------------------------------
int main(void)
{	
	int maxy, maxx, height, width;
	WINDOW **new_win;
	Player_packet *player_packet;

	getmaxhw(&maxy, &maxx, &height, &width);
	new_win = make_layout(maxy, maxx, height, width);

	show_history(new_win, NULL);
	getchar();
	return 0;
}
// -------------------------------------------------------



// 맵의 말 위치, 자신의 카드 4장, 히스토리, 진행 상황을 화면에 업데이트하는 함수
int ui_update(WINDOW *window, Player_packet* player_packet)
{
	// change_player_position();
	// show_my_card();
	show_history(window, player_packet);
	// show_game_log(window, player_packet, SITU_GOLDEN_CARD);

	return 0;
}


/* 화면에 히스토리 부분을 출력하는 함수 */
int show_history(WINDOW *window[], Player_packet *player_packet)
{
	/* 플레이어의 패킷이 아예 없을 경우 */
	if(player_packet == NULL)
	{
		wprintw(window, "player packet is NULL!");	
		return -1;
	}

	// parsing....

	// int scene_input = PLAYER_INFER_SCENE(player_packet->infer);
	// int weapon_input = PLAYER_INFER_WEAPON(player_packet->infer);
	// int criminal_input = PLAYER_INFER_CRIMINAL(player_packet->infer);

	int scene_input = 0x6;
	int weapon_input = 0x5;
	int criminal_input = 0x4;

	char criminal[8];
	char weapon[16];
	char scene[16];

	/* criminal table */
	/*
	000 : KimKH
	001 : KimWS
	010 : KimJS
	011 : BakWC
	100 : ShinJS
	101 : JeonKA
	*/
	
	switch(criminal_input<<=2)
	{
		case 0:
			strcpy(criminal, "KimKH");
			break;
		case 1:
			strcpy(criminal, "KimWS");
			break;
		case 2:
			strcpy(criminal, "KimJS");
			break;
		case 3:
			strcpy(criminal, "BakWC");
			break;
		case 4:
			strcpy(criminal, "ShinJH");
			break;
		case 5:
			strcpy(criminal, "JeonKA");
			break;
	}

	/* weapon table */
	/*
	000 : knife
	001 : umbrella
	010 : punch
	011 : MacBook
	100 : chair
	101 : cable
	110 : ZUGA ------> very critical weapon. DO NOT TOUCH
	*/

	switch(weapon_input<<=2)
	{
		case 0:
			strcpy(weapon, "knife");
			break;
		case 1:
			strcpy(weapon, "umbrella");
			break;
		case 2:
			strcpy(weapon, "punch");
			break;
		case 3:
			strcpy(weapon, "MacBook");
			break;
		case 4:
			strcpy(weapon, "chair");
			break;
		case 5:
			strcpy(weapon, "cable");
			break;
		case 6:
			strcpy(weapon, "ZUGA");
			break;
	}

	/* scene table */
	/*
	000 : classroom
	001 : restroom
	010 : training
	011 : office
	100 : kitchen
	101 : hall
	111 : ROOM_OF_TRUTH
	*/

	switch(scene_input<<=2)
	{
		case 0:
			strcpy(scene, "classroom");
			break;
		case 1:
			strcpy(scene, "restroom");
			break;
		case 2:
			strcpy(scene, "training");
			break;
		case 3:
			strcpy(scene, "office");
			break;
		case 4:
			strcpy(scene, "kitchen");
			break;
		case 5:
			strcpy(scene, "hall");
			break;
		case 7:
			strcpy(scene, "ROOM_OF_TRUTH");
			break;
	}

	char temp[64] = { 0, };
	
	strcat(temp, scene);
	strcat(temp, " / ");
	strcat(temp, criminal);
	strcat(temp, " / ");
	strcat(temp, weapon);
	strcpy(history[history_cnt], temp);
	history_cnt++;
	
	print_history(window, 0);
	return 0;
}


void print_history(WINDOW *window, int start_index)
// start_index : 히스토리 내역을 저장하고 있는 history[] 배열에서 출력을 시작할 원소의 첫번째 위치 정보를 가지고 있는 변수
{
	char** history_list[16];

	for(int i=0; i<16; i++)
	{
		memmove(history_list[i], history[start_index+i], sizeof(char**));
		mvwprintw(window, i+1, 5, "%s", history_list[i]);
	}
	wrefresh(window);
}


/* 화면의 게임 진행부분(로그) 부분을 출력하는 함수 */
// int show_game_log(WINDOW *window, Player_packet *player_packet)
int show_game_log(WINDOW* window[], Player_packet *player_packet, int situation)
{
	if(player_packet==NULL)
	{
		wprintw(window, "player packet is null");
		return -1;
	}
	int player = PLAYER_ID(player_packet->info);
	int dice_value = PLAYER_DICE_VALUE(player_packet->dice);
	int dice_select = PLAYER_SELECT_VALUE(player_packet->dice);
	/*  
	   1. 굴려서 얻은 주사위 값을 나타내는 로그
	   2. 굴린 주사위에서 선택한 값을 나타내는 로그
	   3. 황금 카드 발동을 나타내는 로그
	   4. 턴 정보를 나타내는 로그
	   5. 플레이어 승리를 나타내는 로그
	   6. 플레이어 패배를 나타내는 로그
	*/

	
	switch(situation)
	{
		case SITU_DICE_ROLL:		
			wprintw(window, "'PLAYER %d' rolled dice '%d'", player, dice_value);
			break;
		case SITU_DICE_SELECT:
			wprintw(window, "'PLAYER %d' selected number '%d'", player, dice_select);
			break;
		case SITU_GOLDEN_CARD:
			wprintw(window, "'PLAYER %d' activated a golden card", player);
			break;
		case SITU_TURN_INFO:
			wprintw(window, "this turn : 'PLAYER %d'", player);
			break;
		case SITU_WIN:
			wprintw(window, "'PLAYER %d' won", player);
			break;
		case SITU_LOSE:
			wprintw(window, "'PLAYER %d' lose", player);
			break;
	}
	return 0;
}
